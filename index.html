<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Hazard: Viral Sanitization Protocol</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000814;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #001d3d 0%, #000814 100%);
            background-size: cover;
            background-position: center;
        }

        #gameCanvas {
            cursor: none;
            display: block;
            touch-action: none;
            position: absolute;
            top: 0;
            left: 0;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 30px;
            color: #00ff88;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 30px #00ff88;
            letter-spacing: 2px;
        }

        #level {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #ff00ff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff;
            letter-spacing: 2px;
        }

        #stats {
            position: absolute;
            top: 60px;
            left: 30px;
            color: #00d9ff;
            font-size: 16px;
            text-shadow: 0 0 5px #00d9ff;
            letter-spacing: 1px;
        }

        #shots {
            position: absolute;
            top: 60px;
            right: 30px;
            color: #ffbe0b;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffbe0b, 0 0 20px #ffbe0b;
            letter-spacing: 1px;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #score, #level {
                font-size: 20px;
                top: 10px;
                left: 15px;
            }

            #level {
                left: auto;
                right: 15px;
            }

            #stats, #shots {
                font-size: 14px;
                top: 40px;
                left: 15px;
            }

            #shots {
                left: auto;
                right: 15px;
            }

            #message {
                font-size: 32px;
            }

            #info {
                font-size: 14px;
                bottom: 15px;
            }

            #location {
                font-size: 18px;
                bottom: 45px;
            }
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 52px;
            font-weight: bold;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
        }

        #message.show {
            opacity: 1;
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            text-align: center;
            transition: opacity 0.3s;
            text-shadow: 0 0 10px #fff;
        }

        #location {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b00;
            font-size: 22px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 15px #ff6b00, 0 0 25px #ff6b00;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #location.show {
            opacity: 1;
        }

        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate(-2px, -2px) rotate(-1deg); }
            20%, 80% { transform: translate(3px, 3px) rotate(1deg); }
            30%, 50%, 70% { transform: translate(-4px, 2px) rotate(-2deg); }
            40%, 60% { transform: translate(4px, -2px) rotate(2deg); }
        }

        .float-score {
            position: absolute;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 10px currentColor;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px) scale(1.5);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="level">LEVEL: 1</div>
        <div id="stats">CHAIN: 0x | SANITIZED: 0/0</div>
        <div id="shots">SHOTS: 4</div>
        <div id="message"></div>
        <div id="location"></div>
        <div id="info">CLICK TO DEPLOY SANITIZATION ZONE<br>Target: 70% Viral Elimination</div>
    </div>

    <script>
        // Canvas setup
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const ui = {
            score: document.getElementById('score'),
            level: document.getElementById('level'),
            stats: document.getElementById('stats'),
            shots: document.getElementById('shots'),
            message: document.getElementById('message'),
            location: document.getElementById('location'),
            info: document.getElementById('info')
        };

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!game.isPlaying) initLevel();
        });

        // Contaminated locations (progression environments)
        const locations = [
            { name: 'BATHROOM TOILET', image: 'background-01.0' },
            { name: 'MOBILE PHONE', image: 'background-02.0' },
            { name: 'COMPUTER KEYBOARD', image: 'background-03.0' },
            { name: 'DOOR HANDLE', image: 'background-04.0' },
            { name: 'KITCHEN SINK', image: 'background-05.0' },
            { name: 'ELEVATOR BUTTON', image: 'background-06.0' },
            { name: 'ATM MACHINE', image: 'background-07.0' },
            { name: 'RESTAURANT TABLE', image: 'background-08.0' },
            { name: 'GYM EQUIPMENT', image: 'background-09.0' },
            { name: 'SHOPPING CART', image: 'background-10.0' }
        ];

        // Detect mobile device
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
                        (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

        // Game state
        const game = {
            score: 0,
            level: 1,
            viruses: [],
            sanitizationZones: [],
            particles: [],
            floatingTexts: [],
            isPlaying: false,
            levelCompleting: false,
            shotsRemaining: 4,
            totalViruses: 0,
            sanitizedViruses: 0,
            chainCount: 0,
            time: 0,
            maxParticles: 300,
            mouseX: 0,
            mouseY: 0,
            showReticle: false,
            isMobile: isMobile,
            // Combo system
            combo: 0,
            comboMultiplier: 1,
            comboTimer: 0,
            lastKillTime: 0,
            comboDecayTime: 2000 // 2 seconds to maintain combo
        };

        // Virus types with special abilities
        const virusTypes = {
            NORMAL: 'normal',
            KAMIKAZE: 'kamikaze',   // IMMUNE to sanitization zones - must be caught by chain reaction from other viruses
            SPLITTER: 'splitter',   // Splits into 2 when killed
            TANK: 'tank',           // Requires 2 hits
            SPEED: 'speed'          // Moves 3x faster
        };

        // Color palettes for virus types
        const virusTypeColors = {
            normal: [
                { primary: '#39ff14', secondary: '#1c7a0a', name: 'Acid Green' },
                { primary: '#bf00ff', secondary: '#5c007a', name: 'Bio-Purple' },
                { primary: '#00f5ff', secondary: '#007a82', name: 'Toxic Cyan' }
            ],
            kamikaze: { primary: '#ff0000', secondary: '#8b0000', name: 'Kamikaze Red' },
            splitter: { primary: '#ff8c00', secondary: '#cc6600', name: 'Splitter Orange' },
            tank: { primary: '#9932cc', secondary: '#6a0dad', name: 'Tank Purple' },
            speed: { primary: '#ffff00', secondary: '#cccc00', name: 'Speed Yellow' }
        };

        // Virus class with procedural generation and special types
        class Virus {
            constructor(x, y, isKing = false, virusType = virusTypes.NORMAL, parentSize = null) {
                this.x = x;
                this.y = y;
                this.isKing = isKing;
                this.virusType = virusType;

                // Size adjustments
                let sizeMultiplier = 1;
                if (parentSize) {
                    sizeMultiplier = 0.6; // Splitter children are smaller
                }
                if (virusType === virusTypes.TANK) {
                    sizeMultiplier = 1.3; // Tanks are bigger
                }

                this.baseRadius = isKing ? 25 : 12 * sizeMultiplier;
                this.radius = this.baseRadius;
                this.destroyed = false;
                this.dying = false;
                this.deathPhase = 0;
                this.deathProgress = 0;

                // Special type properties
                this.hits = (virusType === virusTypes.TANK) ? 2 : 1;
                this.maxHits = this.hits;

                // Procedural personality
                if (isKing) {
                    this.colorScheme = { primary: '#ffd700', secondary: '#ff8c00', name: 'King Virus' };
                } else if (virusType === virusTypes.NORMAL) {
                    this.colorScheme = virusTypeColors.normal[Math.floor(Math.random() * virusTypeColors.normal.length)];
                } else {
                    this.colorScheme = virusTypeColors[virusType];
                }

                // Eye variations: 1 large, 2 erratic, or multiple tiny
                this.eyeType = Math.floor(Math.random() * 3);
                this.eyeCount = this.eyeType === 0 ? 1 : this.eyeType === 1 ? 2 : Math.floor(Math.random() * 3) + 3;
                this.eyeJitter = 0;
                this.eyeOffsets = [];
                for (let i = 0; i < this.eyeCount; i++) {
                    this.eyeOffsets.push({
                        x: (Math.random() - 0.5) * this.baseRadius * 0.8,
                        y: (Math.random() - 0.5) * this.baseRadius * 0.8,
                        size: this.eyeType === 0 ? 6 : this.eyeType === 1 ? 4 : 2
                    });
                }

                // Spike pattern
                this.spikeCount = Math.floor(Math.random() * 6) + 6;
                this.spikes = [];
                for (let i = 0; i < this.spikeCount; i++) {
                    this.spikes.push({
                        angle: (Math.PI * 2 / this.spikeCount) * i + Math.random() * 0.3,
                        length: Math.random() * 0.5 + 0.5,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                // Brownian motion parameters with level scaling and type modifiers
                const baseSpeed = 1.5;
                const panicSpeedMultiplier = 1 + (game.level - 1) * 0.05 || 1;

                // Speed multipliers per type
                let typeSpeedMultiplier = 1;
                if (virusType === virusTypes.SPEED) {
                    typeSpeedMultiplier = 3;
                } else if (virusType === virusTypes.TANK) {
                    typeSpeedMultiplier = 0.5;
                } else if (virusType === virusTypes.KAMIKAZE) {
                    typeSpeedMultiplier = 1.5;
                }

                this.baseSpeed = baseSpeed * panicSpeedMultiplier * typeSpeedMultiplier;
                this.targetVX = (Math.random() - 0.5) * this.baseSpeed;
                this.targetVY = (Math.random() - 0.5) * this.baseSpeed;
                this.vx = this.targetVX;
                this.vy = this.targetVY;
                this.directionChangeTimer = Math.random() * 120 + 60;
                this.isPanicked = false;
                const fleeRadiusConst = 1; // (Math.floor(Math.random() * 10) / 10);
                this.fleeRadius = fleeRadiusConst * 150; // Randomized between 0 and 1 times normal
                this.closestZone = null;

                // Animation
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.rotation = 0;

                // King virus crown
                if (isKing) {
                    this.crownPoints = 5;
                }
            }

            update(deltaTime) {
                if (this.destroyed) return;

                // Handle death sequence
                if (this.dying) {
                    this.deathProgress += 0.05;

                    if (this.deathProgress < 0.33) {
                        // Phase 1: Shrink
                        this.deathPhase = 1;
                        this.radius = this.baseRadius * (1 - this.deathProgress * 3);
                    } else if (this.deathProgress < 0.66) {
                        // Phase 2: Bleach
                        this.deathPhase = 2;
                    } else if (this.deathProgress < 1) {
                        // Phase 3: Dissolve
                        this.deathPhase = 3;
                    } else {
                        this.destroyed = true;
                    }
                    return;
                }

                // Kamikaze viruses IGNORE everything - just pure Brownian motion
                if (this.virusType === virusTypes.KAMIKAZE) {
                    // Kamikaze viruses are fearless - they don't react to cursor or zones
                    this.isPanicked = false;

                    // Normal Brownian motion only
                    this.directionChangeTimer--;
                    if (this.directionChangeTimer <= 0) {
                        this.targetVX = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                        this.targetVY = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                        this.directionChangeTimer = Math.random() * 120 + 60;
                    }
                } else {
                    // Evade AI - Flee from cursor (for non-Kamikaze viruses)
                    const dx = game.mouseX - this.x;
                    const dy = game.mouseY - this.y;
                    const distToCursor = Math.sqrt(dx * dx + dy * dy);

                    if (distToCursor < this.fleeRadius && game.showReticle) {
                        // PANIC MODE: Flee from cursor
                        this.isPanicked = true;
                        const fleeAngle = Math.atan2(dy, dx) + Math.PI; // Opposite direction
                        const fleeSpeed = this.baseSpeed * 1.35;

                        this.targetVX = Math.cos(fleeAngle) * fleeSpeed;
                        this.targetVY = Math.sin(fleeAngle) * fleeSpeed;
                    } else {
                        this.isPanicked = false;

                        // Normal Brownian motion
                        this.directionChangeTimer--;
                        if (this.directionChangeTimer <= 0) {
                            this.targetVX = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                            this.targetVY = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                            this.directionChangeTimer = Math.random() * 120 + 60;
                        }
                    }
                }

                // Smooth velocity transitions
                const smoothing = this.isPanicked ? 0.15 : 0.05;
                this.vx += (this.targetVX - this.vx) * smoothing;
                this.vy += (this.targetVY - this.vy) * smoothing;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Advanced boundary handling with bounce-back and screen wrapping hybrid
                const margin = this.baseRadius * 3;
                const wrapMargin = this.baseRadius;

                // Horizontal boundaries
                if (this.x < -wrapMargin) {
                    // Screen wrap from left to right
                    this.x = canvas.width + wrapMargin;
                } else if (this.x > canvas.width + wrapMargin) {
                    // Screen wrap from right to left
                    this.x = -wrapMargin;
                } else if (this.x < margin) {
                    // Soft bounce from left edge
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.8;
                    this.targetVX = Math.abs(this.targetVX);
                } else if (this.x > canvas.width - margin) {
                    // Soft bounce from right edge
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.8;
                    this.targetVX = -Math.abs(this.targetVX);
                }

                // Vertical boundaries
                if (this.y < -wrapMargin) {
                    // Screen wrap from top to bottom
                    this.y = canvas.height + wrapMargin;
                } else if (this.y > canvas.height + wrapMargin) {
                    // Screen wrap from bottom to top
                    this.y = -wrapMargin;
                } else if (this.y < margin) {
                    // Soft bounce from top edge
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.8;
                    this.targetVY = Math.abs(this.targetVY);
                } else if (this.y > canvas.height - margin) {
                    // Soft bounce from bottom edge
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.8;
                    this.targetVY = -Math.abs(this.targetVY);
                }

                // Animation updates (faster when panicked)
                const animSpeed = this.isPanicked ? 0.08 : 0.05;
                this.pulsePhase += animSpeed;
                this.rotation += this.rotationSpeed * (this.isPanicked ? 1.5 : 1);
                this.eyeJitter = Math.random() * (this.isPanicked ? 3 : 2) - (this.isPanicked ? 1.5 : 1);
            }

            draw() {
                if (this.destroyed) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Death phase rendering
                if (this.dying) {
                    if (this.deathPhase === 2) {
                        // Bleaching effect
                        const bleachAmount = (this.deathProgress - 0.33) * 3;
                        ctx.globalAlpha = 1 - bleachAmount * 0.5;
                    } else if (this.deathPhase === 3) {
                        // Dissolving effect
                        ctx.globalAlpha = 1 - ((this.deathProgress - 0.66) * 3);
                    }
                }

                const pulseIntensity = this.isPanicked ? 0.25 : 0.15;
                const pulse = Math.sin(this.pulsePhase) * pulseIntensity + 1;
                const currentRadius = this.radius * pulse;

                // Draw spikes (undulating membrane)
                const color = this.dying && this.deathPhase >= 2 ? '#ffffff' : this.colorScheme.primary;
                const secondaryColor = this.dying && this.deathPhase >= 2 ? '#e0e0e0' : this.colorScheme.secondary;

                ctx.shadowBlur = this.isKing ? 30 : 15;
                ctx.shadowColor = color;

                // Irregular cell membrane with spikes
                ctx.beginPath();
                for (let i = 0; i < this.spikeCount; i++) {
                    const spike = this.spikes[i];
                    const nextSpike = this.spikes[(i + 1) % this.spikeCount];

                    const spikeWave = Math.sin(game.time * 0.05 + spike.phase) * 0.3 + 1;
                    const spikeLength = currentRadius * (1 + spike.length * spikeWave * 0.4);

                    const x1 = Math.cos(spike.angle) * spikeLength;
                    const y1 = Math.sin(spike.angle) * spikeLength;

                    if (i === 0) {
                        ctx.moveTo(x1, y1);
                    } else {
                        ctx.lineTo(x1, y1);
                    }
                }
                ctx.closePath();

                // Gradient fill
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.7, secondaryColor);
                gradient.addColorStop(1, color);
                ctx.fillStyle = gradient;
                ctx.fill();

                // King virus crown
                if (this.isKing && !this.dying) {
                    ctx.strokeStyle = '#ffe234';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffe234';

                    ctx.beginPath();
                    for (let i = 0; i <= this.crownPoints; i++) {
                        const angle = -Math.PI / 2 + (Math.PI / this.crownPoints) * i;
                        const r = currentRadius + 8 + (i % 2 === 0 ? 6 : 0);
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r - currentRadius * 0.7;

                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Visual indicators for special virus types
                if (!this.dying) {
                    ctx.shadowBlur = 0;

                    // Tank virus - show health bar
                    if (this.virusType === virusTypes.TANK && this.hits < this.maxHits) {
                        const barWidth = currentRadius * 1.5;
                        const barHeight = 4;
                        const barX = -barWidth / 2;
                        const barY = currentRadius + 8;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(barX, barY, barWidth * (this.hits / this.maxHits), barHeight);
                    }

                    // Kamikaze virus - IMMUNE indicator
                    if (this.virusType === virusTypes.KAMIKAZE) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ðŸ›¡', 0, currentRadius + 15);

                        // Add pulsing shield effect
                        const shieldPulse = Math.sin(game.time * 0.1) * 0.3 + 0.7;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${shieldPulse})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, currentRadius + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Speed virus - lightning symbol
                    if (this.virusType === virusTypes.SPEED) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('âš¡', 0, currentRadius + 15);
                    }
                }

                // Draw eyes with jitter
                if (!this.dying || this.deathPhase < 2) {
                    this.eyeOffsets.forEach(eye => {
                        const jitterX = this.eyeJitter * 0.5;
                        const jitterY = this.eyeJitter * 0.5;

                        // Eye white
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(eye.x + jitterX, eye.y + jitterY, eye.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupil
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(
                            eye.x + jitterX + this.eyeJitter * 0.3,
                            eye.y + jitterY + this.eyeJitter * 0.3,
                            eye.size * 0.5,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    });
                }

                ctx.restore();
            }

            takeDamage() {
                if (this.dying || this.destroyed) return { killed: false, shouldSplit: false };

                this.hits--;

                if (this.hits <= 0) {
                    this.dying = true;
                    const shouldSplit = this.virusType === virusTypes.SPLITTER;
                    return { killed: true, shouldSplit: shouldSplit };
                }

                // Tank virus damaged but not killed - visual feedback
                if (this.virusType === virusTypes.TANK) {
                    // Flash effect
                    this.pulsePhase += Math.PI;
                }

                return { killed: false, shouldSplit: false };
            }
        }

        // Sanitization Zone (Explosion)
        class SanitizationZone {
            constructor(x, y, isKing = false) {
                this.x = x;
                this.y = y;
                this.radius = 0;

                // Reduce radius by half on mobile devices
                const radiusMultiplier = game.isMobile ? 0.5 : 1;
                this.maxRadius = isKing ? 400 * radiusMultiplier : 200 * radiusMultiplier;

                this.growing = true;
                this.life = 1;
                this.isKing = isKing;
                this.growthRate = isKing ? 8 : 6;
            }

            update() {
                if (this.growing) {
                    this.radius += this.growthRate;
                    if (this.radius >= this.maxRadius) {
                        this.growing = false;
                    }
                } else {
                    this.life -= 0.02;
                }
                return this.life > 0;
            }

            draw() {
                // Validate coordinates before drawing
                if (isNaN(this.x) || isNaN(this.y) || isNaN(this.radius) || this.radius <= 0) {
                    return;
                }

                ctx.save();

                // Outer glow
                const outerGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                outerGradient.addColorStop(0, `rgba(0, 255, 255, ${this.life * 0.4})`);
                outerGradient.addColorStop(0.5, `rgba(255, 255, 255, ${this.life * 0.3})`);
                outerGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner core
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.isKing ? '#ffd700' : '#00ffff';
                ctx.strokeStyle = this.isKing ? '#ffd700' : '#ffffff';
                ctx.lineWidth = this.isKing ? 6 : 4;
                ctx.globalAlpha = this.life * 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.9, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            checkCollision(virus) {
                if (virus.destroyed || virus.dying) return false;
                // Use distance squared to avoid expensive sqrt
                const dx = this.x - virus.x;
                const dy = this.y - virus.y;
                const distSquared = dx * dx + dy * dy;
                const radiusSum = this.radius + virus.radius;
                return distSquared <= radiusSum * radiusSum;
            }
        }

        // Particle (cellular debris)
        class Particle {
            constructor(x, y, color, isKing = false) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (isKing ? 12 : 8) + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = 0.025; // Faster decay for better performance
                this.size = Math.random() * (isKing ? 6 : 4) + 2;
                this.color = color;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= this.decay;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Square particles for cellular debris
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);

                ctx.restore();
            }
        }

        // Floating score text
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1;
                this.vy = -2;
            }

            update() {
                this.y += this.vy;
                this.life -= 0.03; // Faster fade for performance
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.font = 'bold 28px "Courier New"';
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        // Audio context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.15) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playSanitizationSound() {
            playSound(800, 0.15, 'sine', 0.2);
        }

        function playKingSound() {
            playSound(400, 0.4, 'sawtooth', 0.25);
            setTimeout(() => playSound(600, 0.3, 'sawtooth', 0.25), 100);
        }

        function playLevelUpSound() {
            playSound(400, 0.5, 'triangle', 0.25);
            setTimeout(() => playSound(600, 0.4, 'triangle', 0.25), 150);
            setTimeout(() => playSound(800, 0.3, 'triangle', 0.25), 300);
        }

        // Screen shake
        function shake(intensity = 1) {
            canvas.style.transform = `translate(${(Math.random() - 0.5) * 10 * intensity}px, ${(Math.random() - 0.5) * 10 * intensity}px)`;
            setTimeout(() => {
                canvas.style.transform = '';
            }, 100);
        }

        // Show message
        function showMessage(text, duration = 2000) {
            ui.message.innerHTML = text;
            ui.message.classList.add('show');
            setTimeout(() => {
                ui.message.classList.remove('show');
            }, duration);
        }

        // Create particles with limit
        function createParticles(x, y, count, color, isKing = false) {
            // Limit particle creation if too many exist
            const actualCount = Math.min(count, game.maxParticles - game.particles.length);
            for (let i = 0; i < actualCount; i++) {
                game.particles.push(new Particle(x, y, color, isKing));
            }
        }

        // Create floating text
        function createFloatingText(x, y, text, color) {
            game.floatingTexts.push(new FloatingText(x, y, text, color));
        }

        // Set background image based on level
        function setLevelBackground() {
            const levelIndex = (game.level - 1) % locations.length;
            const location = locations[levelIndex];

            // Try to load background image, fallback to gradient
            const img = new Image();
            img.onload = function() {
                console.log('Background image loaded:', location.image);
                gameContainer.style.backgroundImage = `url('${location.image}')`;
                gameContainer.style.backgroundSize = 'cover';
                gameContainer.style.backgroundPosition = 'center';
            };
            img.onerror = function() {
                console.log('Background image failed to load:', location.image);
                // Fallback to gradient if image not found
                gameContainer.style.backgroundImage = '';
            };
            img.src = location.image;

            // Show location name
            ui.location.textContent = `CONTAMINATED: ${location.name}`;
            ui.location.classList.add('show');
            setTimeout(() => {
                ui.location.classList.remove('show');
            }, 3000);
        }

        // Initialize level
        function initLevel() {
            game.viruses = [];
            game.sanitizationZones = [];
            game.particles = [];
            game.floatingTexts = [];
            game.shotsRemaining = 4;
            game.sanitizedViruses = 0;
            game.chainCount = 0;
            game.levelCompleting = false;
            game.combo = 0;
            game.comboMultiplier = 1;
            game.lastKillTime = 0;

            // Set environment background
            setLevelBackground();

            // Increase virus count with level
            const virusCount = 20 + game.level * 5;
            game.totalViruses = virusCount;

            // Create viruses with varied types
            for (let i = 0; i < virusCount; i++) {
                const margin = 50;
                const x = Math.random() * (canvas.width - margin * 2) + margin;
                const y = Math.random() * (canvas.height - margin * 2) + margin;

                // Determine virus type with escalating special virus rates
                const rand = Math.random();
                const specialRate = Math.min(0.3 + game.level * 0.05, 0.6); // Max 60% special

                let virusType = virusTypes.NORMAL;
                let isKing = false;

                if (rand < 0.1) {
                    isKing = true; // 10% King
                } else if (rand < 0.1 + specialRate) {
                    // Special virus distribution
                    const typeRand = Math.random();
                    if (typeRand < 0.25) {
                        virusType = virusTypes.KAMIKAZE;
                    } else if (typeRand < 0.5) {
                        virusType = virusTypes.SPLITTER;
                    } else if (typeRand < 0.75) {
                        virusType = virusTypes.TANK;
                    } else {
                        virusType = virusTypes.SPEED;
                    }
                }

                game.viruses.push(new Virus(x, y, isKing, virusType));
            }

            game.isPlaying = true;
            updateUI();
        }

        // Handle mouse move for reticle
        function handleMouseMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0];
            const x = (touch?.clientX || e.clientX);
            const y = (touch?.clientY || e.clientY);

            // Validate coordinates
            if (typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y)) {
                game.mouseX = x - rect.left;
                game.mouseY = y - rect.top;
                game.showReticle = true;
            }
        }

        // Handle touch start (show reticle immediately)
        function handleTouchStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0];

            if (touch) {
                const x = touch.clientX;
                const y = touch.clientY;

                // Validate coordinates
                if (typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y)) {
                    game.mouseX = x - rect.left;
                    game.mouseY = y - rect.top;
                    game.showReticle = true;
                }
            }
        }

        // Handle touch end (keep reticle visible for a moment)
        function handleTouchEnd(e) {
            e.preventDefault();
            // Keep reticle visible briefly after touch
            setTimeout(() => {
                if (!e.touches || e.touches.length === 0) {
                    game.showReticle = false;
                }
            }, 100);
        }

        // Handle mouse leave
        function handleMouseLeave() {
            game.showReticle = false;
        }

        // Handle click
        function handleClick(e) {
            if (!game.isPlaying || game.shotsRemaining <= 0) return;

            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0] || e.changedTouches?.[0];
            const clientX = touch?.clientX || e.clientX;
            const clientY = touch?.clientY || e.clientY;

            // Validate coordinates before using them
            if (typeof clientX !== 'number' || typeof clientY !== 'number' ||
                isNaN(clientX) || isNaN(clientY)) {
                console.error('Invalid click coordinates');
                return;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Update cursor position for touch devices
            game.mouseX = x;
            game.mouseY = y;
            game.showReticle = true;

            // Hide info on first shot
            if (game.shotsRemaining === 4) {
                ui.info.style.opacity = '0';
            }

            // Create sanitization zone
            game.sanitizationZones.push(new SanitizationZone(x, y));
            game.shotsRemaining--;
            playSanitizationSound();
            createParticles(x, y, 30, '#00ffff');
            updateUI();
        }

        // Check level completion
        function checkLevelComplete() {
            if (game.levelCompleting || game.shotsRemaining > 0 || game.sanitizationZones.length > 0) return;

            game.levelCompleting = true;
            game.isPlaying = false;

            const percentSanitized = (game.sanitizedViruses / game.totalViruses) * 100;

            if (percentSanitized >= 70) {
                // Success!
                const bonus = Math.floor(percentSanitized * 15) * game.level;
                game.score += bonus;
                game.level++;

                shake(2);
                playLevelUpSound();
                showMessage(
                    `LEVEL ${game.level} PROTOCOL ACTIVATED<br>` +
                    `<span style="font-size: 32px; color: #00ff88">${Math.floor(percentSanitized)}% SANITIZED | ${game.chainCount}x CHAIN</span>`,
                    1200
                );

                setTimeout(() => {
                    ui.info.style.opacity = '1';
                    initLevel();
                }, 1200);
            } else {
                // Fail
                showMessage(
                    `SANITIZATION FAILED<br>` +
                    `<span style="font-size: 32px; color: #ff0066">Only ${Math.floor(percentSanitized)}% Eliminated</span>`,
                    1200
                );
                setTimeout(() => {
                    game.level = Math.max(1, game.level - 1);
                    ui.info.style.opacity = '1';
                    initLevel();
                }, 1200);
            }
        }

        // Update UI
        function updateUI() {
            ui.score.textContent = `SCORE: ${game.score}`;
            ui.level.textContent = `LEVEL: ${game.level}`;

            // Show combo in stats if active
            const comboText = game.combo > 1 ? ` | ${game.combo}x COMBO` : '';
            ui.stats.textContent = `CHAIN: ${game.chainCount}x | SANITIZED: ${game.sanitizedViruses}/${game.totalViruses}${comboText}`;
            ui.shots.textContent = `SHOTS: ${game.shotsRemaining}`;
        }

        // Draw targeting reticle
        function drawReticle() {
            if (!game.showReticle || !game.isPlaying) return;

            ctx.save();

            // Outer circle (sanitization zone preview) - adjusted for mobile
            const zoneRadius = game.isMobile ? 100 : 200;
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(game.mouseX, game.mouseY, zoneRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner reticle
            ctx.setLineDash([]);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;

            // Crosshair
            const crossSize = 15;
            ctx.beginPath();
            ctx.moveTo(game.mouseX - crossSize, game.mouseY);
            ctx.lineTo(game.mouseX + crossSize, game.mouseY);
            ctx.moveTo(game.mouseX, game.mouseY - crossSize);
            ctx.lineTo(game.mouseX, game.mouseY + crossSize);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(game.mouseX, game.mouseY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Corner brackets
            const bracketSize = 25;
            const bracketDist = 20;
            ctx.lineWidth = 3;

            // Top-left
            ctx.beginPath();
            ctx.moveTo(game.mouseX - bracketDist, game.mouseY - bracketDist + bracketSize);
            ctx.lineTo(game.mouseX - bracketDist, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX - bracketDist + bracketSize, game.mouseY - bracketDist);
            ctx.stroke();

            // Top-right
            ctx.beginPath();
            ctx.moveTo(game.mouseX + bracketDist - bracketSize, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY - bracketDist + bracketSize);
            ctx.stroke();

            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(game.mouseX - bracketDist, game.mouseY + bracketDist - bracketSize);
            ctx.lineTo(game.mouseX - bracketDist, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX - bracketDist + bracketSize, game.mouseY + bracketDist);
            ctx.stroke();

            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(game.mouseX + bracketDist - bracketSize, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY + bracketDist - bracketSize);
            ctx.stroke();

            // Shots remaining indicator
            if (game.shotsRemaining > 0) {
                ctx.fillStyle = '#ffbe0b';
                ctx.font = 'bold 14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffbe0b';
                ctx.fillText(`${game.shotsRemaining}`, game.mouseX, game.mouseY + 45);
            }

            ctx.restore();
        }

        // Game loop
        let lastTime = performance.now();
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 16.67; // Normalize to 60fps
            lastTime = currentTime;
            game.time += deltaTime;

            // Clear canvas completely to show background
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw viruses (optimized loop)
            for (let i = 0; i < game.viruses.length; i++) {
                const virus = game.viruses[i];
                virus.update(deltaTime);
                virus.draw();
            }

            // Update and draw sanitization zones
            game.sanitizationZones = game.sanitizationZones.filter(zone => {
                const alive = zone.update();
                zone.draw();

                // Check collisions with viruses
                if (zone.growing) {
                    game.viruses.forEach(virus => {

                        if (zone.checkCollision(virus)) {
                            const damageResult = virus.takeDamage();

                            if (damageResult.killed) {
                                game.sanitizedViruses++;
                                game.chainCount++;

                                // Update combo system
                                const now = Date.now();
                                if (now - game.lastKillTime < game.comboDecayTime) {
                                    game.combo++;
                                } else {
                                    game.combo = 1;
                                }
                                game.lastKillTime = now;

                                // Calculate combo multiplier
                                if (game.combo >= 5) {
                                    game.comboMultiplier = 3;
                                } else if (game.combo >= 3) {
                                    game.comboMultiplier = 2;
                                } else {
                                    game.comboMultiplier = 1;
                                }

                                const isKing = virus.isKing;
                                const basePoints = isKing ? 25 : 5;
                                const points = Math.floor(basePoints * game.comboMultiplier);
                                game.score += points;

                                // Create new sanitization zone
                                game.sanitizationZones.push(new SanitizationZone(virus.x, virus.y, isKing));

                                // Handle Splitter virus - spawn 2 smaller viruses
                                if (damageResult.shouldSplit) {
                                    const angle1 = Math.random() * Math.PI * 2;
                                    const angle2 = angle1 + Math.PI;
                                    const dist = 30;

                                    game.viruses.push(new Virus(
                                        virus.x + Math.cos(angle1) * dist,
                                        virus.y + Math.sin(angle1) * dist,
                                        false,
                                        virusTypes.NORMAL,
                                        virus.baseRadius
                                    ));

                                    game.viruses.push(new Virus(
                                        virus.x + Math.cos(angle2) * dist,
                                        virus.y + Math.sin(angle2) * dist,
                                        false,
                                        virusTypes.NORMAL,
                                        virus.baseRadius
                                    ));

                                    game.totalViruses += 2;
                                }

                                // Sound and visual effects
                                if (isKing) {
                                    playKingSound();
                                    shake(3);
                                    createParticles(virus.x, virus.y, 50, virus.colorScheme.primary, true);
                                    createFloatingText(virus.x, virus.y, `+${points} KING!`, '#ffd700');
                                } else {
                                    const pitch = 80 + Math.min(game.chainCount * 5, 80);
                                    playSound(pitch, 0.1, 'sine', 0.15);
                                    createParticles(virus.x, virus.y, 25, virus.colorScheme.primary);

                                    // Show combo multiplier
                                    if (game.comboMultiplier > 1) {
                                        const comboColor = game.comboMultiplier === 3 ? '#ff00ff' : '#ffff00';
                                        createFloatingText(virus.x, virus.y, `${game.combo}x COMBO! +${points}`, comboColor);
                                    } else if (game.sanitizedViruses % 3 === 0) {
                                        createFloatingText(virus.x, virus.y, `+${points}`, virus.colorScheme.primary);
                                    }
                                }

                                updateUI();
                            }
                        }
                    });
                }

                return alive;
            });

            // Remove destroyed viruses
            game.viruses = game.viruses.filter(v => !v.destroyed);

            // Update and draw particles (batch for performance)
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }

            // Update and draw floating texts (batch for performance)
            for (let i = game.floatingTexts.length - 1; i >= 0; i--) {
                const t = game.floatingTexts[i];
                t.update();
                t.draw();
                if (t.life <= 0) {
                    game.floatingTexts.splice(i, 1);
                }
            }

            // Update combo decay
            if (game.combo > 0 && Date.now() - game.lastKillTime > game.comboDecayTime) {
                game.combo = 0;
                game.comboMultiplier = 1;
                updateUI();
            }

            // Draw targeting reticle
            drawReticle();

            // Check level completion
            checkLevelComplete();

            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', handleMouseLeave);

        // Touch events (mobile support)
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Tap to shoot on mobile (with debounce to prevent double-firing)
        let lastTouchEnd = 0;
        canvas.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd < 300) {
                // Prevent rapid double-taps
                e.preventDefault();
                return;
            }
            lastTouchEnd = now;

            if (e.changedTouches && e.changedTouches.length > 0) {
                handleClick(e);
            }
        }, { passive: false });

        // Start game
        initLevel();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
