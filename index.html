<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Hazard: Viral Sanitization Protocol</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000814;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #001d3d 0%, #000814 100%);
            background-size: cover;
            background-position: center;
        }

        #gameCanvas {
            cursor: none;
            display: block;
            touch-action: none;
            position: absolute;
            top: 0;
            left: 0;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 30px;
            color: #00ff88;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 30px #00ff88;
            letter-spacing: 2px;
        }

        #level {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #ff00ff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff;
            letter-spacing: 2px;
        }

        #stats {
            position: absolute;
            top: 60px;
            left: 30px;
            color: #00d9ff;
            font-size: 16px;
            text-shadow: 0 0 5px #00d9ff;
            letter-spacing: 1px;
        }

        #shots {
            position: absolute;
            top: 60px;
            right: 30px;
            color: #ffbe0b;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffbe0b, 0 0 20px #ffbe0b;
            letter-spacing: 1px;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            #score, #level {
                font-size: 20px;
                top: 10px;
                left: 15px;
            }

            #level {
                left: auto;
                right: 15px;
            }

            #stats, #shots {
                font-size: 14px;
                top: 40px;
                left: 15px;
            }

            #shots {
                left: auto;
                right: 15px;
            }

            #message {
                font-size: 32px;
            }

            #info {
                font-size: 14px;
                bottom: 15px;
            }

            #location {
                font-size: 18px;
                bottom: 45px;
            }
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 52px;
            font-weight: bold;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
        }

        #message.show {
            opacity: 1;
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            text-align: center;
            transition: opacity 0.3s;
            text-shadow: 0 0 10px #fff;
        }

        #location {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff6b00;
            font-size: 22px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 15px #ff6b00, 0 0 25px #ff6b00;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #location.show {
            opacity: 1;
        }

        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate(-2px, -2px) rotate(-1deg); }
            20%, 80% { transform: translate(3px, 3px) rotate(1deg); }
            30%, 50%, 70% { transform: translate(-4px, 2px) rotate(-2deg); }
            40%, 60% { transform: translate(4px, -2px) rotate(2deg); }
        }

        .float-score {
            position: absolute;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 10px currentColor;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px) scale(1.5);
            }
        }

        /* Leaderboard Modal */
        #leaderboardModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #leaderboardModal.show {
            display: flex;
        }

        .leaderboard-content {
            background: linear-gradient(135deg, #001d3d 0%, #000814 100%);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        .leaderboard-title {
            color: #00ffff;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #00ffff;
        }

        .leaderboard-list {
            margin-bottom: 30px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            margin: 10px 0;
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid;
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 5px currentColor;
        }

        .leaderboard-item.rank-1 {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
        }

        .leaderboard-item.rank-2 {
            border-left-color: #c0c0c0;
            background: rgba(192, 192, 192, 0.15);
        }

        .leaderboard-item.rank-3 {
            border-left-color: #cd7f32;
            background: rgba(205, 127, 50, 0.15);
        }

        .leaderboard-rank {
            font-size: 28px;
            font-weight: bold;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            margin-left: 20px;
        }

        .leaderboard-level {
            color: #00ff88;
            font-weight: bold;
        }

        .leaderboard-close {
            background: #ff0066;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            width: 100%;
            transition: all 0.3s;
            text-shadow: 0 0 10px #ff0066;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
            pointer-events: auto;
        }

        .leaderboard-close:hover {
            background: #ff3385;
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .leaderboard-content {
                padding: 30px 20px;
            }

            .leaderboard-title {
                font-size: 28px;
            }

            .leaderboard-item {
                font-size: 16px;
                padding: 12px 15px;
            }

            .leaderboard-rank {
                font-size: 22px;
            }
        }

        /* Achievement System Styles */
        #achievementButton {
            position: absolute;
            top: 100px;
            right: 30px;
            font-size: 32px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            pointer-events: auto;
            z-index: 20;
        }

        #achievementButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        @media (max-width: 768px) {
            #achievementButton {
                top: 80px;
                right: 15px;
                font-size: 24px;
                padding: 8px 12px;
            }
        }

        /* Toast Notification */
        .achievement-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: linear-gradient(135deg, #001d3d 0%, #000814 100%);
            border: 3px solid #ffd700;
            border-radius: 10px;
            padding: 15px 25px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
            z-index: 10000;
            opacity: 0;
            transition: all 0.5s ease-out;
            pointer-events: none;
        }

        .achievement-toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        @media (max-width: 768px) {
            .achievement-toast {
                font-size: 14px;
                padding: 12px 20px;
            }
        }

        /* Achievement Modal */
        #achievementModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        #achievementModal.show {
            display: flex;
        }

        .achievement-content {
            background: linear-gradient(135deg, #001d3d 0%, #000814 100%);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        .achievement-title {
            color: #ffd700;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #ffd700;
        }

        .achievement-list {
            margin-bottom: 30px;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .achievement-item.locked {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .achievement-item.unlocked {
            box-shadow: 0 0 15px;
        }

        .achievement-item.bronze {
            border-left-color: #cd7f32;
        }

        .achievement-item.silver {
            border-left-color: #c0c0c0;
        }

        .achievement-item.gold {
            border-left-color: #ffd700;
        }

        .achievement-item.unlocked.bronze {
            box-shadow: 0 0 15px rgba(205, 127, 50, 0.6);
        }

        .achievement-item.unlocked.silver {
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.6);
        }

        .achievement-item.unlocked.gold {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        .achievement-icon {
            font-size: 32px;
            margin-right: 15px;
            min-width: 40px;
            text-align: center;
        }

        .achievement-details {
            flex: 1;
        }

        .achievement-name {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #fff;
        }

        .achievement-desc {
            color: #00d9ff;
            font-size: 14px;
        }

        .achievement-close {
            background: #ff0066;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            width: 100%;
            transition: all 0.3s;
            text-shadow: 0 0 10px #ff0066;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
            pointer-events: auto;
        }

        .achievement-close:hover {
            background: #ff3385;
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .achievement-content {
                padding: 30px 20px;
            }

            .achievement-title {
                font-size: 28px;
            }

            .achievement-item {
                padding: 12px;
            }

            .achievement-icon {
                font-size: 24px;
            }

            .achievement-name {
                font-size: 16px;
            }

            .achievement-desc {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="level">LEVEL: 1</div>
        <div id="stats">CHAIN: 0x | SANITIZED: 0/0</div>
        <div id="shots">SHOTS: 4</div>
        <div id="message"></div>
        <div id="location"></div>
        <div id="info">CLICK TO DEPLOY SANITIZATION ZONE<br>Target: 70% Viral Elimination</div>
        <button id="achievementButton" onclick="openAchievements()">üèÜ</button>
    </div>

    <!-- Achievement Toast Notification -->
    <div id="achievementToast" class="achievement-toast"></div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal">
        <div class="leaderboard-content">
            <div class="leaderboard-title">üèÜ LEADERBOARD üèÜ</div>
            <div class="leaderboard-list" id="leaderboardList">
                <!-- Will be populated by JavaScript -->
            </div>
            <button class="leaderboard-close" onclick="closeLeaderboard()">CONTINUE</button>
        </div>
    </div>

    <!-- Achievement Modal -->
    <div id="achievementModal">
        <div class="achievement-content">
            <div class="achievement-title">üèÜ ACHIEVEMENTS üèÜ</div>
            <div class="achievement-list" id="achievementList">
                <!-- Will be populated by JavaScript -->
            </div>
            <button class="achievement-close" onclick="closeAchievements()">CLOSE</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const ui = {
            score: document.getElementById('score'),
            level: document.getElementById('level'),
            stats: document.getElementById('stats'),
            shots: document.getElementById('shots'),
            message: document.getElementById('message'),
            location: document.getElementById('location'),
            info: document.getElementById('info')
        };

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!game.isPlaying) initLevel();
        });

        // Contaminated locations (progression environments)
        const locations = [
            { name: 'BATHROOM TOILET', image: 'background-01.0' },
            { name: 'MOBILE PHONE', image: 'background-02.0' },
            { name: 'COMPUTER KEYBOARD', image: 'background-03.0' },
            { name: 'DOOR HANDLE', image: 'background-04.0' },
            { name: 'KITCHEN SINK', image: 'background-05.0' },
            { name: 'ELEVATOR BUTTON', image: 'background-06.0' },
            { name: 'ATM MACHINE', image: 'background-07.0' },
            { name: 'RESTAURANT TABLE', image: 'background-08.0' },
            { name: 'GYM EQUIPMENT', image: 'background-09.0' },
            { name: 'SHOPPING CART', image: 'background-10.0' }
        ];

        // Detect mobile device
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
                        (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);

        // Achievement System
        const achievements = [
            {
                id: "first_blood",
                tier: "bronze",
                title: "Sanitizer Initiate",
                description: "Clear your first contaminated location.",
                condition: "level > 1"
            },
            {
                id: "clean_sweep",
                tier: "silver",
                title: "Sterile Perfection",
                description: "Eliminate 100% of viruses in a single level.",
                condition: "last_level_sanitized == 100"
            },
            {
                id: "sniper",
                tier: "gold",
                title: "One Shot, One Kill",
                description: "Clear a level using only 1 shot.",
                condition: "shots_used == 1 && level_won == true"
            },
            {
                id: "pacifist_victory",
                tier: "gold",
                title: "Angel's Work",
                description: "Win a level with 0 shots used (Let the Helper do the work).",
                condition: "shots_used == 0 && level_won == true"
            },
            {
                id: "speed_demon",
                tier: "silver",
                title: "Flash Sterilization",
                description: "Complete a level in under 5 seconds.",
                condition: "level_time < 5"
            },
            {
                id: "giant_slayer",
                tier: "silver",
                title: "Regicide",
                description: "Destroy a King Virus and a Boss in the same level.",
                condition: "king_killed > 0 && boss_killed == true"
            },
            {
                id: "chain_master",
                tier: "gold",
                title: "Nuclear Reaction",
                description: "Trigger a chain reaction of 50 or more viruses.",
                condition: "max_chain >= 50"
            },
            {
                id: "close_call",
                tier: "bronze",
                title: "Living on the Edge",
                description: "Clear a level with exactly 70% (The bare minimum).",
                condition: "sanitized_percent == 70"
            },
            {
                id: "heartbreaker",
                tier: "bronze",
                title: "Unfriendly Fire",
                description: "Accidentally kill the Helper Virus (and survive the doubling).",
                condition: "helper_killed == true && level_won == true"
            },
            {
                id: "untouchable",
                tier: "gold",
                title: "Bio-Security Expert",
                description: "Reach Level 10 without losing a single time.",
                condition: "level == 10 && total_losses == 0"
            }
        ];

        // Game state
        const game = {
            score: 0,
            level: 1,
            viruses: [],
            sanitizationZones: [],
            particles: [],
            floatingTexts: [],
            isPlaying: false,
            levelCompleting: false,
            shotsRemaining: 4,
            totalViruses: 0,
            sanitizedViruses: 0,
            chainCount: 0,
            time: 0,
            maxParticles: 300,
            mouseX: 0,
            mouseY: 0,
            showReticle: false,
            isMobile: isMobile,
            // Combo system
            combo: 0,
            comboMultiplier: 1,
            comboTimer: 0,
            lastKillTime: 0,
            comboDecayTime: 2000, // 2 seconds to maintain combo
            // Progression tracking
            totalLosses: 0,
            highestLevel: 1,
            // Special viruses
            hasHelper: false,
            hasBoss: false,
            bossKilled: false,
            // Achievement tracking (per level)
            levelStartTime: 0,
            shotsUsed: 0,
            kingKilledThisLevel: 0,
            helperKilledThisLevel: false,
            maxChainThisLevel: 0
        };

        // Virus types with special abilities
        const virusTypes = {
            NORMAL: 'normal',
            KAMIKAZE: 'kamikaze',   // Fearless - immune to flee behavior
            SPLITTER: 'splitter',   // Splits into 2 when killed
            TANK: 'tank',           // Requires 2 hits
            SPEED: 'speed',         // Moves 3x faster
            HELPER: 'helper',       // White angel - helps kill viruses, BUT if killed all viruses double!
            BOSS: 'boss'            // Dark boss - 3 stages, must be killed to win
        };

        // Color palettes for virus types
        const virusTypeColors = {
            normal: [
                { primary: '#39ff14', secondary: '#1c7a0a', name: 'Acid Green' },
                { primary: '#bf00ff', secondary: '#5c007a', name: 'Bio-Purple' },
                { primary: '#00f5ff', secondary: '#007a82', name: 'Toxic Cyan' }
            ],
            kamikaze: { primary: '#ff0000', secondary: '#8b0000', name: 'Kamikaze Red' },
            splitter: { primary: '#ff8c00', secondary: '#cc6600', name: 'Splitter Orange' },
            tank: { primary: '#9932cc', secondary: '#6a0dad', name: 'Tank Purple' },
            speed: { primary: '#ffff00', secondary: '#cccc00', name: 'Speed Yellow' },
            helper: { primary: '#ffffff', secondary: '#e0e0e0', name: 'Helper White' },
            boss: { primary: '#2a2a2a', secondary: '#000000', name: 'Boss Dark' }
        };

        // Virus class with procedural generation and special types
        class Virus {
            constructor(x, y, isKing = false, virusType = virusTypes.NORMAL, parentSize = null) {
                this.x = x;
                this.y = y;
                this.isKing = isKing;
                this.virusType = virusType;

                // Size adjustments
                let sizeMultiplier = 1;
                if (parentSize) {
                    sizeMultiplier = 0.6; // Splitter children are smaller
                }
                if (virusType === virusTypes.TANK) {
                    sizeMultiplier = 1.3; // Tanks are bigger
                }
                if (virusType === virusTypes.HELPER) {
                    sizeMultiplier = 1.2; // Helper is slightly bigger
                }
                if (virusType === virusTypes.BOSS) {
                    sizeMultiplier = 2.5; // Boss starts HUGE (35px)
                }

                this.baseRadius = isKing ? 25 : 12 * sizeMultiplier;
                this.radius = this.baseRadius;
                this.destroyed = false;
                this.dying = false;
                this.deathPhase = 0;
                this.deathProgress = 0;

                // Special type properties
                this.hits = (virusType === virusTypes.TANK) ? 2 : (virusType === virusTypes.BOSS) ? 3 : 1;
                this.maxHits = this.hits;

                // Boss stages
                if (virusType === virusTypes.BOSS) {
                    this.bossStage = 1; // Stages: 1, 2, 3
                }

                // Procedural personality
                if (isKing) {
                    this.colorScheme = { primary: '#ffd700', secondary: '#ff8c00', name: 'King Virus' };
                } else if (virusType === virusTypes.NORMAL) {
                    this.colorScheme = virusTypeColors.normal[Math.floor(Math.random() * virusTypeColors.normal.length)];
                } else {
                    this.colorScheme = virusTypeColors[virusType];
                }

                // Eye variations: 1 large, 2 erratic, or multiple tiny
                this.eyeType = Math.floor(Math.random() * 3);
                this.eyeCount = this.eyeType === 0 ? 1 : this.eyeType === 1 ? 2 : Math.floor(Math.random() * 3) + 3;
                this.eyeJitter = 0;
                this.eyeOffsets = [];
                for (let i = 0; i < this.eyeCount; i++) {
                    this.eyeOffsets.push({
                        x: (Math.random() - 0.5) * this.baseRadius * 0.8,
                        y: (Math.random() - 0.5) * this.baseRadius * 0.8,
                        size: this.eyeType === 0 ? 6 : this.eyeType === 1 ? 4 : 2
                    });
                }

                // Spike pattern
                this.spikeCount = Math.floor(Math.random() * 6) + 6;
                this.spikes = [];
                for (let i = 0; i < this.spikeCount; i++) {
                    this.spikes.push({
                        angle: (Math.PI * 2 / this.spikeCount) * i + Math.random() * 0.3,
                        length: Math.random() * 0.5 + 0.5,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                // Brownian motion parameters with level scaling and type modifiers
                const baseSpeed = 1.5;
                const panicSpeedMultiplier = 1 + (game.level - 1) * 0.05 || 1;

                // Speed multipliers per type
                let typeSpeedMultiplier = 1;
                if (virusType === virusTypes.SPEED) {
                    typeSpeedMultiplier = 3;
                } else if (virusType === virusTypes.TANK) {
                    typeSpeedMultiplier = 0.5;
                } else if (virusType === virusTypes.KAMIKAZE) {
                    typeSpeedMultiplier = 1.5;
                } else if (virusType === virusTypes.HELPER) {
                    typeSpeedMultiplier = 0.8; // Helper moves slower
                } else if (virusType === virusTypes.BOSS) {
                    // Boss speed increases with stage
                    typeSpeedMultiplier = 1;
                }

                this.baseSpeed = baseSpeed * panicSpeedMultiplier * typeSpeedMultiplier;
                this.targetVX = (Math.random() - 0.5) * this.baseSpeed;
                this.targetVY = (Math.random() - 0.5) * this.baseSpeed;
                this.vx = this.targetVX;
                this.vy = this.targetVY;
                this.directionChangeTimer = Math.random() * 120 + 60;
                this.isPanicked = false;
                const fleeRadiusConst = 1; // (Math.floor(Math.random() * 10) / 10);
                this.fleeRadius = fleeRadiusConst * 150; // Randomized between 0 and 1 times normal
                this.closestZone = null;

                // Animation
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.rotation = 0;

                // King virus crown
                if (isKing) {
                    this.crownPoints = 5;
                }
            }

            update(deltaTime) {
                if (this.destroyed) return;

                // Handle death sequence
                if (this.dying) {
                    this.deathProgress += 0.05;

                    if (this.deathProgress < 0.33) {
                        // Phase 1: Shrink
                        this.deathPhase = 1;
                        this.radius = this.baseRadius * (1 - this.deathProgress * 3);
                    } else if (this.deathProgress < 0.66) {
                        // Phase 2: Bleach
                        this.deathPhase = 2;
                    } else if (this.deathProgress < 1) {
                        // Phase 3: Dissolve
                        this.deathPhase = 3;
                    } else {
                        this.destroyed = true;
                    }
                    return;
                }

                // Kamikaze and Helper viruses IGNORE cursor - just pure Brownian motion
                if (this.virusType === virusTypes.KAMIKAZE || this.virusType === virusTypes.HELPER) {
                    // These viruses are fearless/independent - they don't react to cursor
                    this.isPanicked = false;

                    // Normal Brownian motion only
                    this.directionChangeTimer--;
                    if (this.directionChangeTimer <= 0) {
                        this.targetVX = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                        this.targetVY = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                        this.directionChangeTimer = Math.random() * 120 + 60;
                    }
                } else {
                    // Evade AI - Flee from cursor (for non-Kamikaze viruses)
                    const dx = game.mouseX - this.x;
                    const dy = game.mouseY - this.y;
                    const distToCursor = Math.sqrt(dx * dx + dy * dy);

                    if (distToCursor < this.fleeRadius && game.showReticle) {
                        // PANIC MODE: Flee from cursor
                        this.isPanicked = true;
                        const fleeAngle = Math.atan2(dy, dx) + Math.PI; // Opposite direction
                        const fleeSpeed = this.baseSpeed * 1.35;

                        this.targetVX = Math.cos(fleeAngle) * fleeSpeed;
                        this.targetVY = Math.sin(fleeAngle) * fleeSpeed;
                    } else {
                        this.isPanicked = false;

                        // Normal Brownian motion
                        this.directionChangeTimer--;
                        if (this.directionChangeTimer <= 0) {
                            this.targetVX = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                            this.targetVY = (Math.random() - 0.5) * this.baseSpeed * 1.25;
                            this.directionChangeTimer = Math.random() * 120 + 60;
                        }
                    }
                }

                // Smooth velocity transitions
                const smoothing = this.isPanicked ? 0.15 : 0.05;
                this.vx += (this.targetVX - this.vx) * smoothing;
                this.vy += (this.targetVY - this.vy) * smoothing;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Advanced boundary handling with bounce-back and screen wrapping hybrid
                const margin = this.baseRadius * 3;
                const wrapMargin = this.baseRadius;

                // Horizontal boundaries
                if (this.x < -wrapMargin) {
                    // Screen wrap from left to right
                    this.x = canvas.width + wrapMargin;
                } else if (this.x > canvas.width + wrapMargin) {
                    // Screen wrap from right to left
                    this.x = -wrapMargin;
                } else if (this.x < margin) {
                    // Soft bounce from left edge
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.8;
                    this.targetVX = Math.abs(this.targetVX);
                } else if (this.x > canvas.width - margin) {
                    // Soft bounce from right edge
                    this.x = canvas.width - margin;
                    this.vx = -Math.abs(this.vx) * 0.8;
                    this.targetVX = -Math.abs(this.targetVX);
                }

                // Vertical boundaries
                if (this.y < -wrapMargin) {
                    // Screen wrap from top to bottom
                    this.y = canvas.height + wrapMargin;
                } else if (this.y > canvas.height + wrapMargin) {
                    // Screen wrap from bottom to top
                    this.y = -wrapMargin;
                } else if (this.y < margin) {
                    // Soft bounce from top edge
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.8;
                    this.targetVY = Math.abs(this.targetVY);
                } else if (this.y > canvas.height - margin) {
                    // Soft bounce from bottom edge
                    this.y = canvas.height - margin;
                    this.vy = -Math.abs(this.vy) * 0.8;
                    this.targetVY = -Math.abs(this.targetVY);
                }

                // Animation updates (faster when panicked)
                const animSpeed = this.isPanicked ? 0.08 : 0.05;
                this.pulsePhase += animSpeed;
                this.rotation += this.rotationSpeed * (this.isPanicked ? 1.5 : 1);
                this.eyeJitter = Math.random() * (this.isPanicked ? 3 : 2) - (this.isPanicked ? 1.5 : 1);
            }

            draw() {
                if (this.destroyed) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Death phase rendering
                if (this.dying) {
                    if (this.deathPhase === 2) {
                        // Bleaching effect
                        const bleachAmount = (this.deathProgress - 0.33) * 3;
                        ctx.globalAlpha = 1 - bleachAmount * 0.5;
                    } else if (this.deathPhase === 3) {
                        // Dissolving effect
                        ctx.globalAlpha = 1 - ((this.deathProgress - 0.66) * 3);
                    }
                }

                const pulseIntensity = this.isPanicked ? 0.25 : 0.15;
                const pulse = Math.sin(this.pulsePhase) * pulseIntensity + 1;
                const currentRadius = this.radius * pulse;

                // Draw spikes (undulating membrane)
                const color = this.dying && this.deathPhase >= 2 ? '#ffffff' : this.colorScheme.primary;
                const secondaryColor = this.dying && this.deathPhase >= 2 ? '#e0e0e0' : this.colorScheme.secondary;

                ctx.shadowBlur = this.isKing ? 30 : 15;
                ctx.shadowColor = color;

                // Irregular cell membrane with spikes
                ctx.beginPath();
                for (let i = 0; i < this.spikeCount; i++) {
                    const spike = this.spikes[i];
                    const nextSpike = this.spikes[(i + 1) % this.spikeCount];

                    const spikeWave = Math.sin(game.time * 0.05 + spike.phase) * 0.3 + 1;
                    const spikeLength = currentRadius * (1 + spike.length * spikeWave * 0.4);

                    const x1 = Math.cos(spike.angle) * spikeLength;
                    const y1 = Math.sin(spike.angle) * spikeLength;

                    if (i === 0) {
                        ctx.moveTo(x1, y1);
                    } else {
                        ctx.lineTo(x1, y1);
                    }
                }
                ctx.closePath();

                // Gradient fill
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.7, secondaryColor);
                gradient.addColorStop(1, color);
                ctx.fillStyle = gradient;
                ctx.fill();

                // King virus crown
                if (this.isKing && !this.dying) {
                    ctx.strokeStyle = '#ffe234';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffe234';

                    ctx.beginPath();
                    for (let i = 0; i <= this.crownPoints; i++) {
                        const angle = -Math.PI / 2 + (Math.PI / this.crownPoints) * i;
                        const r = currentRadius + 8 + (i % 2 === 0 ? 6 : 0);
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r - currentRadius * 0.7;

                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }

                // Visual indicators for special virus types
                if (!this.dying) {
                    ctx.shadowBlur = 0;

                    // Tank virus - show health bar
                    if (this.virusType === virusTypes.TANK && this.hits < this.maxHits) {
                        const barWidth = currentRadius * 1.5;
                        const barHeight = 4;
                        const barX = -barWidth / 2;
                        const barY = currentRadius + 8;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(barX, barY, barWidth * (this.hits / this.maxHits), barHeight);
                    }

                    // Kamikaze virus - IMMUNE indicator
                    if (this.virusType === virusTypes.KAMIKAZE) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üõ°', 0, currentRadius + 15);

                        // Add pulsing shield effect
                        const shieldPulse = Math.sin(game.time * 0.1) * 0.3 + 0.7;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${shieldPulse})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, currentRadius + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Speed virus - lightning symbol
                    if (this.virusType === virusTypes.SPEED) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚ö°', 0, currentRadius + 15);
                    }

                    // Helper virus - angel/heart symbol with glow
                    if (this.virusType === virusTypes.HELPER) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ü§ç', 0, currentRadius + 20);

                        // Pulsing white aura
                        const auraPulse = Math.sin(game.time * 0.08) * 0.3 + 0.7;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${auraPulse})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, currentRadius + 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Boss virus - skull/demon symbol and health bar
                    if (this.virusType === virusTypes.BOSS) {
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('üëø', 0, currentRadius + 25);

                        // Health bar
                        const barWidth = currentRadius * 2;
                        const barHeight = 6;
                        const barX = -barWidth / 2;
                        const barY = currentRadius + 30;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        const healthPercent = this.hits / this.maxHits;
                        const barColor = healthPercent > 0.66 ? '#ff0000' : healthPercent > 0.33 ? '#ff6600' : '#ffaa00';
                        ctx.fillStyle = barColor;
                        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

                        // Stage indicator
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(`STAGE ${this.bossStage}`, 0, currentRadius + 42);
                    }
                }

                // Draw eyes with jitter
                if (!this.dying || this.deathPhase < 2) {
                    this.eyeOffsets.forEach(eye => {
                        const jitterX = this.eyeJitter * 0.5;
                        const jitterY = this.eyeJitter * 0.5;

                        // Eye white
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(eye.x + jitterX, eye.y + jitterY, eye.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupil
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(
                            eye.x + jitterX + this.eyeJitter * 0.3,
                            eye.y + jitterY + this.eyeJitter * 0.3,
                            eye.size * 0.5,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    });
                }

                ctx.restore();
            }

            takeDamage() {
                if (this.dying || this.destroyed) return { killed: false, shouldSplit: false, isHelper: false, isBoss: false };

                this.hits--;

                // Boss stage progression
                if (this.virusType === virusTypes.BOSS && this.hits > 0) {
                    this.bossStage++;

                    // Stage 2: 2x speed, darker
                    if (this.bossStage === 2) {
                        this.baseSpeed *= 2;
                        this.targetVX *= 2;
                        this.targetVY *= 2;
                        this.colorScheme = { primary: '#1a1a1a', secondary: '#000000', name: 'Boss Angry' };
                    }
                    // Stage 3: 3x speed (cumulative = 6x), tiny size
                    else if (this.bossStage === 3) {
                        this.baseSpeed *= 1.5;
                        this.targetVX *= 1.5;
                        this.targetVY *= 1.5;
                        this.baseRadius = this.baseRadius / 10; // Shrink to 1/10 size
                        this.radius = this.baseRadius;
                        this.colorScheme = { primary: '#0a0a0a', secondary: '#000000', name: 'Boss Enraged' };
                    }

                    // Flash effect
                    this.pulsePhase += Math.PI;
                    return { killed: false, shouldSplit: false, isHelper: false, isBoss: false };
                }

                if (this.hits <= 0) {
                    this.dying = true;
                    const shouldSplit = this.virusType === virusTypes.SPLITTER;
                    const isHelper = this.virusType === virusTypes.HELPER;
                    const isBoss = this.virusType === virusTypes.BOSS;
                    return { killed: true, shouldSplit: shouldSplit, isHelper: isHelper, isBoss: isBoss };
                }

                // Tank virus damaged but not killed - visual feedback
                if (this.virusType === virusTypes.TANK) {
                    // Flash effect
                    this.pulsePhase += Math.PI;
                }

                return { killed: false, shouldSplit: false, isHelper: false, isBoss: false };
            }
        }

        // Sanitization Zone (Explosion)
        class SanitizationZone {
            constructor(x, y, isKing = false, isPlayerCreated = false) {
                this.x = x;
                this.y = y;
                this.radius = 0;

                // Reduce radius by half on mobile devices
                const radiusMultiplier = game.isMobile ? 0.5 : 1;
                this.maxRadius = isKing ? 400 * radiusMultiplier : 200 * radiusMultiplier;

                this.growing = true;
                this.life = 1;
                this.isKing = isKing;
                this.growthRate = isKing ? 8 : 6;
                this.isPlayerCreated = isPlayerCreated; // Track if player directly created this zone
                this.hitViruses = new Set(); // Track which viruses have already been hit by this zone
            }

            update() {
                if (this.growing) {
                    this.radius += this.growthRate;
                    if (this.radius >= this.maxRadius) {
                        this.growing = false;
                    }
                } else {
                    this.life -= 0.02;
                }
                return this.life > 0;
            }

            draw() {
                // Validate coordinates before drawing
                if (isNaN(this.x) || isNaN(this.y) || isNaN(this.radius) || this.radius <= 0) {
                    return;
                }

                ctx.save();

                // Outer glow
                const outerGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                outerGradient.addColorStop(0, `rgba(0, 255, 255, ${this.life * 0.4})`);
                outerGradient.addColorStop(0.5, `rgba(255, 255, 255, ${this.life * 0.3})`);
                outerGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner core
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.isKing ? '#ffd700' : '#00ffff';
                ctx.strokeStyle = this.isKing ? '#ffd700' : '#ffffff';
                ctx.lineWidth = this.isKing ? 6 : 4;
                ctx.globalAlpha = this.life * 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.9, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            checkCollision(virus) {
                if (virus.destroyed || virus.dying) return false;
                // Use distance squared to avoid expensive sqrt
                const dx = this.x - virus.x;
                const dy = this.y - virus.y;
                const distSquared = dx * dx + dy * dy;
                const radiusSum = this.radius + virus.radius;
                return distSquared <= radiusSum * radiusSum;
            }
        }

        // Particle (cellular debris)
        class Particle {
            constructor(x, y, color, isKing = false) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (isKing ? 12 : 8) + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = 0.025; // Faster decay for better performance
                this.size = Math.random() * (isKing ? 6 : 4) + 2;
                this.color = color;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.97;
                this.vy *= 0.97;
                this.life -= this.decay;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Square particles for cellular debris
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);

                ctx.restore();
            }
        }

        // Floating score text
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1;
                this.vy = -2;
            }

            update() {
                this.y += this.vy;
                this.life -= 0.03; // Faster fade for performance
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.font = 'bold 28px "Courier New"';
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        // Audio context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.15) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playSanitizationSound() {
            playSound(800, 0.15, 'sine', 0.2);
        }

        function playKingSound() {
            playSound(400, 0.4, 'sawtooth', 0.25);
            setTimeout(() => playSound(600, 0.3, 'sawtooth', 0.25), 100);
        }

        function playLevelUpSound() {
            playSound(400, 0.5, 'triangle', 0.25);
            setTimeout(() => playSound(600, 0.4, 'triangle', 0.25), 150);
            setTimeout(() => playSound(800, 0.3, 'triangle', 0.25), 300);
        }

        // Local Storage Functions
        function saveGame() {
            const saveData = {
                score: game.score,
                level: game.level,
                highestLevel: game.highestLevel,
                totalLosses: game.totalLosses
            };
            localStorage.setItem('virusGameSave', JSON.stringify(saveData));
        }

        function loadGame() {
            const saveData = localStorage.getItem('virusGameSave');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    game.score = data.score || 0;
                    game.level = data.level || 1;
                    game.highestLevel = data.highestLevel || 1;
                    game.totalLosses = data.totalLosses || data.consecutiveLosses || 0; // Support old saves
                } catch (e) {
                    console.error('Failed to load save data:', e);
                }
            }
        }

        // Leaderboard Functions
        function initLeaderboard() {
            const leaderboardData = localStorage.getItem('virusGameLeaderboard');
            if (!leaderboardData) {
                // Initialize with default leaders
                const defaultLeaders = [
                    { name: 'Alex', level: 30 },
                    { name: 'Ben', level: 28 },
                    { name: 'Cook', level: 25 }
                ];
                localStorage.setItem('virusGameLeaderboard', JSON.stringify(defaultLeaders));
            }
        }

        function getLeaderboard() {
            const data = localStorage.getItem('virusGameLeaderboard');
            if (data) {
                try {
                    return JSON.parse(data);
                } catch (e) {
                    console.error('Failed to load leaderboard:', e);
                    return [];
                }
            }
            return [];
        }

        function showLeaderboard() {
            const leaderboard = getLeaderboard();
            const leaderboardList = document.getElementById('leaderboardList');
            const modal = document.getElementById('leaderboardModal');

            // Add player to leaderboard for comparison
            const allPlayers = [
                ...leaderboard,
                { name: 'YOU', level: game.highestLevel }
            ];

            // Sort by level (highest first)
            allPlayers.sort((a, b) => b.level - a.level);

            // Build leaderboard HTML
            let html = '';
            allPlayers.forEach((player, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                const isYou = player.name === 'YOU';
                const highlightStyle = isYou ? 'style="background: rgba(255, 215, 0, 0.2); border-left-color: #ffd700;"' : '';

                html += `
                    <div class="leaderboard-item ${rankClass}" ${highlightStyle}>
                        <div class="leaderboard-rank">${medal}</div>
                        <div class="leaderboard-name">${player.name}${isYou ? ' ‚≠ê' : ''}</div>
                        <div class="leaderboard-level">Level ${player.level}</div>
                    </div>
                `;
            });

            leaderboardList.innerHTML = html;
            modal.classList.add('show');
            game.isPlaying = false; // Pause game
        }

        function closeLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            modal.classList.remove('show');
            // Don't automatically resume - let player click to continue
        }

        // Achievement Functions
        function initAchievements() {
            const achievementData = localStorage.getItem('virusAchievements');
            if (!achievementData) {
                // Initialize empty achievement tracking
                localStorage.setItem('virusAchievements', JSON.stringify([]));
            }
        }

        function getUnlockedAchievements() {
            const data = localStorage.getItem('virusAchievements');
            if (data) {
                try {
                    return JSON.parse(data);
                } catch (e) {
                    console.error('Failed to load achievements:', e);
                    return [];
                }
            }
            return [];
        }

        function isAchievementUnlocked(achievementId) {
            const unlocked = getUnlockedAchievements();
            return unlocked.includes(achievementId);
        }

        function unlockAchievement(achievementId) {
            if (isAchievementUnlocked(achievementId)) {
                return false; // Already unlocked
            }

            const unlocked = getUnlockedAchievements();
            unlocked.push(achievementId);
            localStorage.setItem('virusAchievements', JSON.stringify(unlocked));

            // Find achievement details
            const achievement = achievements.find(a => a.id === achievementId);
            if (achievement) {
                showAchievementToast(achievement);
                playSound(600, 0.3, 'triangle', 0.3);
                setTimeout(() => playSound(800, 0.3, 'triangle', 0.3), 100);
            }

            return true;
        }

        function showAchievementToast(achievement) {
            const toast = document.getElementById('achievementToast');
            toast.innerHTML = `üèÜ Achievement Unlocked: ${achievement.title}`;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        function openAchievements() {
            const modal = document.getElementById('achievementModal');
            const achievementList = document.getElementById('achievementList');
            const unlocked = getUnlockedAchievements();

            let html = '';
            achievements.forEach(achievement => {
                const isUnlocked = unlocked.includes(achievement.id);
                const lockClass = isUnlocked ? 'unlocked' : 'locked';
                const icon = isUnlocked ? 'üèÜ' : 'üîí';

                html += `
                    <div class="achievement-item ${achievement.tier} ${lockClass}">
                        <div class="achievement-icon">${icon}</div>
                        <div class="achievement-details">
                            <div class="achievement-name">${achievement.title}</div>
                            <div class="achievement-desc">${achievement.description}</div>
                        </div>
                    </div>
                `;
            });

            achievementList.innerHTML = html;
            modal.classList.add('show');
            game.isPlaying = false; // Pause game
        }

        function closeAchievements() {
            const modal = document.getElementById('achievementModal');
            modal.classList.remove('show');
            game.isPlaying = true; // Resume game
        }

        function checkAchievements(context) {
            // Context contains: level, shots_used, level_won, sanitized_percent, level_time, etc.
            achievements.forEach(achievement => {
                if (isAchievementUnlocked(achievement.id)) {
                    return; // Skip if already unlocked
                }

                let shouldUnlock = false;

                // Check each achievement condition
                switch (achievement.id) {
                    case 'first_blood':
                        shouldUnlock = context.level > 1;
                        break;
                    case 'clean_sweep':
                        shouldUnlock = context.sanitized_percent === 100 && context.level_won;
                        break;
                    case 'sniper':
                        shouldUnlock = context.shots_used === 1 && context.level_won;
                        break;
                    case 'pacifist_victory':
                        shouldUnlock = context.shots_used === 0 && context.level_won;
                        break;
                    case 'speed_demon':
                        shouldUnlock = context.level_time < 5 && context.level_won;
                        break;
                    case 'giant_slayer':
                        shouldUnlock = context.king_killed > 0 && context.boss_killed && context.level_won;
                        break;
                    case 'chain_master':
                        shouldUnlock = context.max_chain >= 50;
                        break;
                    case 'close_call':
                        shouldUnlock = context.sanitized_percent === 70 && context.level_won;
                        break;
                    case 'heartbreaker':
                        shouldUnlock = context.helper_killed && context.level_won;
                        break;
                    case 'untouchable':
                        shouldUnlock = context.level === 10 && context.total_losses === 0;
                        break;
                }

                if (shouldUnlock) {
                    unlockAchievement(achievement.id);
                }
            });
        }

        // Screen shake
        function shake(intensity = 1) {
            canvas.style.transform = `translate(${(Math.random() - 0.5) * 10 * intensity}px, ${(Math.random() - 0.5) * 10 * intensity}px)`;
            setTimeout(() => {
                canvas.style.transform = '';
            }, 100);
        }

        // Show message
        function showMessage(text, duration = 2000) {
            ui.message.innerHTML = text;
            ui.message.classList.add('show');
            setTimeout(() => {
                ui.message.classList.remove('show');
            }, duration);
        }

        // Create particles with limit
        function createParticles(x, y, count, color, isKing = false) {
            // Limit particle creation if too many exist
            const actualCount = Math.min(count, game.maxParticles - game.particles.length);
            for (let i = 0; i < actualCount; i++) {
                game.particles.push(new Particle(x, y, color, isKing));
            }
        }

        // Create floating text
        function createFloatingText(x, y, text, color) {
            game.floatingTexts.push(new FloatingText(x, y, text, color));
        }

        // Set background image based on level
        function setLevelBackground() {
            const levelIndex = (game.level - 1) % locations.length;
            const location = locations[levelIndex];

            // Try to load background image, fallback to gradient
            const img = new Image();
            img.onload = function() {
                console.log('Background image loaded:', location.image);
                gameContainer.style.backgroundImage = `url('${location.image}')`;
                gameContainer.style.backgroundSize = 'cover';
                gameContainer.style.backgroundPosition = 'center';
            };
            img.onerror = function() {
                console.log('Background image failed to load:', location.image);
                // Fallback to gradient if image not found
                gameContainer.style.backgroundImage = '';
            };
            img.src = location.image;

            // Show location name
            ui.location.textContent = `CONTAMINATED: ${location.name}`;
            ui.location.classList.add('show');
            setTimeout(() => {
                ui.location.classList.remove('show');
            }, 3000);
        }

        // Initialize level
        function initLevel() {
            game.viruses = [];
            game.sanitizationZones = [];
            game.particles = [];
            game.floatingTexts = [];
            game.shotsRemaining = 4;
            game.sanitizedViruses = 0;
            game.chainCount = 0;
            game.levelCompleting = false;
            game.combo = 0;
            game.comboMultiplier = 1;
            game.lastKillTime = 0;
            game.bossKilled = false;

            // Achievement tracking - reset per level
            game.levelStartTime = Date.now();
            game.shotsUsed = 0;
            game.kingKilledThisLevel = 0;
            game.helperKilledThisLevel = false;
            game.maxChainThisLevel = 0;

            // Check for special level types
            game.hasHelper = (game.level % 3 === 0); // Helper at 3, 6, 9, etc.
            game.hasBoss = (game.level % 5 === 0); // Boss at 5, 10, 15, etc.

            // Set environment background
            setLevelBackground();

            // Increase virus count with level
            const virusCount = 20 + game.level * 5;
            game.totalViruses = virusCount;

            // Create viruses with varied types
            for (let i = 0; i < virusCount; i++) {
                const margin = 50;
                const x = Math.random() * (canvas.width - margin * 2) + margin;
                const y = Math.random() * (canvas.height - margin * 2) + margin;

                // Determine virus type with escalating special virus rates
                const rand = Math.random();
                const specialRate = Math.min(0.3 + game.level * 0.05, 0.6); // Max 60% special

                let virusType = virusTypes.NORMAL;
                let isKing = false;

                if (rand < 0.1) {
                    isKing = true; // 10% King
                } else if (rand < 0.1 + specialRate) {
                    // Special virus distribution
                    const typeRand = Math.random();
                    if (typeRand < 0.25) {
                        virusType = virusTypes.KAMIKAZE;
                    } else if (typeRand < 0.5) {
                        virusType = virusTypes.SPLITTER;
                    } else if (typeRand < 0.75) {
                        virusType = virusTypes.TANK;
                    } else {
                        virusType = virusTypes.SPEED;
                    }
                }

                game.viruses.push(new Virus(x, y, isKing, virusType));
            }

            // Spawn Helper virus at 3n levels
            if (game.hasHelper) {
                const margin = 50;
                const x = Math.random() * (canvas.width - margin * 2) + margin;
                const y = Math.random() * (canvas.height - margin * 2) + margin;
                game.viruses.push(new Virus(x, y, false, virusTypes.HELPER));
                // NOTE: Helper does NOT count towards totalViruses for win condition

                showMessage('ü§ç HELPER VIRUS APPEARED ü§ç<br><span style="font-size: 24px;">Keep it alive! If killed, all viruses DOUBLE!</span>', 3000);
            }

            // Spawn Boss virus at 5n levels
            if (game.hasBoss) {
                const margin = 100;
                const x = Math.random() * (canvas.width - margin * 2) + margin;
                const y = Math.random() * (canvas.height - margin * 2) + margin;
                game.viruses.push(new Virus(x, y, false, virusTypes.BOSS));
                game.totalViruses++; // Boss counts towards total

                showMessage('üëø BOSS LEVEL üëø<br><span style="font-size: 24px;">Defeat the Boss to advance!</span>', 3000);
            }

            game.isPlaying = true;
            updateUI();
        }

        // Handle mouse move for reticle
        function handleMouseMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0];
            const x = (touch?.clientX || e.clientX);
            const y = (touch?.clientY || e.clientY);

            // Validate coordinates
            if (typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y)) {
                game.mouseX = x - rect.left;
                game.mouseY = y - rect.top;
                game.showReticle = true;
            }
        }

        // Handle touch start (show reticle immediately)
        function handleTouchStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0];

            if (touch) {
                const x = touch.clientX;
                const y = touch.clientY;

                // Validate coordinates
                if (typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y)) {
                    game.mouseX = x - rect.left;
                    game.mouseY = y - rect.top;
                    game.showReticle = true;
                }
            }
        }

        // Handle touch end (keep reticle visible for a moment)
        function handleTouchEnd(e) {
            e.preventDefault();
            // Keep reticle visible briefly after touch
            setTimeout(() => {
                if (!e.touches || e.touches.length === 0) {
                    game.showReticle = false;
                }
            }, 100);
        }

        // Handle mouse leave
        function handleMouseLeave() {
            game.showReticle = false;
        }

        // Handle click
        function handleClick(e) {
            if (!game.isPlaying || game.shotsRemaining <= 0) return;

            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches?.[0] || e.changedTouches?.[0];
            const clientX = touch?.clientX || e.clientX;
            const clientY = touch?.clientY || e.clientY;

            // Validate coordinates before using them
            if (typeof clientX !== 'number' || typeof clientY !== 'number' ||
                isNaN(clientX) || isNaN(clientY)) {
                console.error('Invalid click coordinates');
                return;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Update cursor position for touch devices
            game.mouseX = x;
            game.mouseY = y;
            game.showReticle = true;

            // Hide info on first shot
            if (game.shotsRemaining === 4) {
                ui.info.style.opacity = '0';
            }

            // Create sanitization zone (player-created)
            game.sanitizationZones.push(new SanitizationZone(x, y, false, true));
            game.shotsRemaining--;
            game.shotsUsed++; // Track shots used for achievements
            playSanitizationSound();
            createParticles(x, y, 30, '#00ffff');
            updateUI();
        }

        // Check for early win (all viruses eliminated before using all shots)
        function checkEarlyWin() {
            if (game.levelCompleting) return;

            // Count remaining non-Helper viruses
            const remainingViruses = game.viruses.filter(v =>
                !v.dying &&
                !v.destroyed &&
                v.virusType !== virusTypes.HELPER
            ).length;

            // Early win conditions
            let shouldComplete = false;
            if (game.hasBoss) {
                // Boss level: boss must be killed and all other viruses eliminated
                shouldComplete = game.bossKilled && remainingViruses === 0;
            } else {
                // Regular level: all non-Helper viruses eliminated
                shouldComplete = remainingViruses === 0;
            }

            if (shouldComplete) {
                // Trigger level complete immediately (even if shots remain)
                checkLevelComplete(true);
            }
        }

        // Check level completion
        function checkLevelComplete(forceComplete = false) {
            // Can complete if: forced (early win) OR no shots remaining
            const canComplete = forceComplete || game.shotsRemaining <= 0;

            if (game.levelCompleting || !canComplete || game.sanitizationZones.length > 0) return;

            game.levelCompleting = true;
            game.isPlaying = false;

            const percentSanitized = (game.sanitizedViruses / game.totalViruses) * 100;

            // Check win condition - Boss levels require boss kill, regular levels require 70%
            let hasWon = false;
            if (game.hasBoss) {
                hasWon = game.bossKilled; // Must kill boss
            } else {
                hasWon = percentSanitized >= 70; // Regular 70% requirement
            }

            if (hasWon) {
                // Success!
                const bonus = Math.floor(percentSanitized * 15) * game.level;
                game.score += bonus;

                // Boss bonus
                if (game.hasBoss && game.bossKilled) {
                    game.score += 100; // Boss kill bonus
                }

                // Calculate level completion time
                const levelTime = (Date.now() - game.levelStartTime) / 1000; // in seconds

                // Check achievements for this level win
                checkAchievements({
                    level: game.level + 1, // Next level we're advancing to
                    shots_used: game.shotsUsed,
                    level_won: true,
                    sanitized_percent: Math.floor(percentSanitized),
                    level_time: levelTime,
                    king_killed: game.kingKilledThisLevel,
                    boss_killed: game.bossKilled,
                    max_chain: game.maxChainThisLevel,
                    helper_killed: game.helperKilledThisLevel,
                    total_losses: game.totalLosses
                });

                game.level++;
                // Note: totalLosses is NEVER reset

                // Update highest level
                if (game.level > game.highestLevel) {
                    game.highestLevel = game.level;
                }

                // Save progress
                saveGame();

                shake(2);
                playLevelUpSound();

                let message = `LEVEL ${game.level} PROTOCOL ACTIVATED<br>` +
                    `<span style="font-size: 32px; color: #00ff88">${Math.floor(percentSanitized)}% SANITIZED | ${game.chainCount}x CHAIN</span>`;

                if (game.hasBoss) {
                    message = `üëø BOSS DEFEATED! üëø<br>` +
                        `<span style="font-size: 32px; color: #ffd700">+100 BONUS | LEVEL ${game.level}</span>`;
                }

                showMessage(message, 1200);

                setTimeout(() => {
                    ui.info.style.opacity = '1';
                    initLevel();
                }, 1200);
            } else {
                // Fail
                game.totalLosses++; // Increment total losses (never resets)
                game.level = Math.max(1, game.level - 1);

                // Save progress
                saveGame();

                let failMessage = `SANITIZATION FAILED<br>` +
                    `<span style="font-size: 32px; color: #ff0066">Only ${Math.floor(percentSanitized)}% Eliminated</span>`;

                if (game.hasBoss && !game.bossKilled) {
                    failMessage = `BOSS SURVIVED<br>` +
                        `<span style="font-size: 32px; color: #ff0066">Boss must be defeated!</span>`;
                }

                showMessage(failMessage, 1200);

                setTimeout(() => {
                    // Check if should show leaderboard after 3 total losses
                    if (game.totalLosses >= 3) {
                        showLeaderboard(); // Don't reset counter - shows every loss after 3rd
                    }

                    ui.info.style.opacity = '1';
                    initLevel();
                }, 1200);
            }
        }

        // Update UI
        function updateUI() {
            ui.score.textContent = `SCORE: ${game.score}`;
            ui.level.textContent = `LEVEL: ${game.level}`;

            // Show combo in stats if active
            const comboText = game.combo > 1 ? ` | ${game.combo}x COMBO` : '';
            ui.stats.textContent = `CHAIN: ${game.chainCount}x | SANITIZED: ${game.sanitizedViruses}/${game.totalViruses}${comboText}`;
            ui.shots.textContent = `SHOTS: ${game.shotsRemaining}`;
        }

        // Draw targeting reticle
        function drawReticle() {
            if (!game.showReticle || !game.isPlaying) return;

            ctx.save();

            // Outer circle (sanitization zone preview) - adjusted for mobile
            const zoneRadius = game.isMobile ? 100 : 200;
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(game.mouseX, game.mouseY, zoneRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner reticle
            ctx.setLineDash([]);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;

            // Crosshair
            const crossSize = 15;
            ctx.beginPath();
            ctx.moveTo(game.mouseX - crossSize, game.mouseY);
            ctx.lineTo(game.mouseX + crossSize, game.mouseY);
            ctx.moveTo(game.mouseX, game.mouseY - crossSize);
            ctx.lineTo(game.mouseX, game.mouseY + crossSize);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(game.mouseX, game.mouseY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Corner brackets
            const bracketSize = 25;
            const bracketDist = 20;
            ctx.lineWidth = 3;

            // Top-left
            ctx.beginPath();
            ctx.moveTo(game.mouseX - bracketDist, game.mouseY - bracketDist + bracketSize);
            ctx.lineTo(game.mouseX - bracketDist, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX - bracketDist + bracketSize, game.mouseY - bracketDist);
            ctx.stroke();

            // Top-right
            ctx.beginPath();
            ctx.moveTo(game.mouseX + bracketDist - bracketSize, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY - bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY - bracketDist + bracketSize);
            ctx.stroke();

            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(game.mouseX - bracketDist, game.mouseY + bracketDist - bracketSize);
            ctx.lineTo(game.mouseX - bracketDist, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX - bracketDist + bracketSize, game.mouseY + bracketDist);
            ctx.stroke();

            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(game.mouseX + bracketDist - bracketSize, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY + bracketDist);
            ctx.lineTo(game.mouseX + bracketDist, game.mouseY + bracketDist - bracketSize);
            ctx.stroke();

            // Shots remaining indicator
            if (game.shotsRemaining > 0) {
                ctx.fillStyle = '#ffbe0b';
                ctx.font = 'bold 14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffbe0b';
                ctx.fillText(`${game.shotsRemaining}`, game.mouseX, game.mouseY + 45);
            }

            ctx.restore();
        }

        // Game loop
        let lastTime = performance.now();
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 16.67; // Normalize to 60fps
            lastTime = currentTime;
            game.time += deltaTime;

            // Clear canvas completely to show background
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw viruses (optimized loop)
            for (let i = 0; i < game.viruses.length; i++) {
                const virus = game.viruses[i];
                virus.update(deltaTime);
                virus.draw();
            }

            // Update and draw sanitization zones
            game.sanitizationZones = game.sanitizationZones.filter(zone => {
                const alive = zone.update();
                zone.draw();

                // Check collisions with viruses
                if (zone.growing) {
                    game.viruses.forEach(virus => {
                        // Skip if this virus has already been hit by this zone
                        if (zone.hitViruses.has(virus)) {
                            return;
                        }

                        // Helper virus is ONLY affected by player-created zones, not chain reactions
                        if (virus.virusType === virusTypes.HELPER && !zone.isPlayerCreated) {
                            return; // Skip Helper for chain reaction zones
                        }

                        // Boss virus is ONLY affected by player-created zones, not chain reactions
                        if (virus.virusType === virusTypes.BOSS && !zone.isPlayerCreated) {
                            return; // Skip Boss for chain reaction zones - must be killed directly!
                        }

                        if (zone.checkCollision(virus)) {
                            // Mark this virus as hit by this zone
                            zone.hitViruses.add(virus);

                            const damageResult = virus.takeDamage();

                            if (damageResult.killed) {
                                game.sanitizedViruses++;
                                game.chainCount++;

                                // Update combo system
                                const now = Date.now();
                                if (now - game.lastKillTime < game.comboDecayTime) {
                                    game.combo++;
                                } else {
                                    game.combo = 1;
                                }
                                game.lastKillTime = now;

                                // Calculate combo multiplier
                                if (game.combo >= 5) {
                                    game.comboMultiplier = 3;
                                } else if (game.combo >= 3) {
                                    game.comboMultiplier = 2;
                                } else {
                                    game.comboMultiplier = 1;
                                }

                                // Handle Boss kill
                                if (damageResult.isBoss) {
                                    game.bossKilled = true;
                                    shake(4);
                                    playSound(200, 0.8, 'sawtooth', 0.3);
                                    createParticles(virus.x, virus.y, 80, '#000000', true);
                                    createFloatingText(virus.x, virus.y, '+100 BOSS DEFEATED!', '#ff0000');
                                    updateUI();
                                    return; // Skip normal processing
                                }

                                // Handle Helper kill - DOUBLE ALL VIRUSES!
                                if (damageResult.isHelper) {
                                    // Helper doesn't count as sanitized
                                    game.sanitizedViruses--;
                                    game.chainCount--;
                                    game.helperKilledThisLevel = true; // Track for achievement

                                    showMessage('‚ö†Ô∏è HELPER KILLED! ‚ö†Ô∏è<br><span style="font-size: 24px; color: #ff0066">ALL VIRUSES DOUBLED!</span>', 2000);
                                    shake(3);
                                    playSound(100, 0.5, 'square', 0.3);

                                    // Double all remaining viruses
                                    const virusesToDouble = game.viruses.filter(v => !v.dying && !v.destroyed && v.virusType !== virusTypes.HELPER);
                                    virusesToDouble.forEach(v => {
                                        const angle = Math.random() * Math.PI * 2;
                                        const dist = 40;
                                        game.viruses.push(new Virus(
                                            v.x + Math.cos(angle) * dist,
                                            v.y + Math.sin(angle) * dist,
                                            false,
                                            v.virusType === virusTypes.BOSS ? virusTypes.NORMAL : v.virusType,
                                            v.baseRadius
                                        ));
                                    });
                                    game.totalViruses += virusesToDouble.length;

                                    createParticles(virus.x, virus.y, 60, '#ffffff', true);
                                    updateUI();
                                    return; // Skip normal processing
                                }

                                const isKing = virus.isKing;
                                if (isKing) {
                                    game.kingKilledThisLevel++; // Track king kills for achievements
                                }
                                const basePoints = isKing ? 25 : 5;
                                const points = Math.floor(basePoints * game.comboMultiplier);
                                game.score += points;

                                // Track max chain for achievements
                                if (game.chainCount > game.maxChainThisLevel) {
                                    game.maxChainThisLevel = game.chainCount;
                                }

                                // Create new sanitization zone (chain reaction - NOT player created)
                                game.sanitizationZones.push(new SanitizationZone(virus.x, virus.y, isKing, false));

                                // Handle Splitter virus - spawn 2 smaller viruses
                                if (damageResult.shouldSplit) {
                                    const angle1 = Math.random() * Math.PI * 2;
                                    const angle2 = angle1 + Math.PI;
                                    const dist = 30;

                                    game.viruses.push(new Virus(
                                        virus.x + Math.cos(angle1) * dist,
                                        virus.y + Math.sin(angle1) * dist,
                                        false,
                                        virusTypes.NORMAL,
                                        virus.baseRadius
                                    ));

                                    game.viruses.push(new Virus(
                                        virus.x + Math.cos(angle2) * dist,
                                        virus.y + Math.sin(angle2) * dist,
                                        false,
                                        virusTypes.NORMAL,
                                        virus.baseRadius
                                    ));

                                    game.totalViruses += 2;
                                }

                                // Sound and visual effects
                                if (isKing) {
                                    playKingSound();
                                    shake(3);
                                    createParticles(virus.x, virus.y, 50, virus.colorScheme.primary, true);
                                    createFloatingText(virus.x, virus.y, `+${points} KING!`, '#ffd700');
                                } else {
                                    const pitch = 80 + Math.min(game.chainCount * 5, 80);
                                    playSound(pitch, 0.1, 'sine', 0.15);
                                    createParticles(virus.x, virus.y, 25, virus.colorScheme.primary);

                                    // Show combo multiplier
                                    if (game.comboMultiplier > 1) {
                                        const comboColor = game.comboMultiplier === 3 ? '#ff00ff' : '#ffff00';
                                        createFloatingText(virus.x, virus.y, `${game.combo}x COMBO! +${points}`, comboColor);
                                    } else if (game.sanitizedViruses % 3 === 0) {
                                        createFloatingText(virus.x, virus.y, `+${points}`, virus.colorScheme.primary);
                                    }
                                }

                                updateUI();

                                // Check for early win after killing viruses
                                checkEarlyWin();
                            }
                        }
                    });
                }

                return alive;
            });

            // Helper virus collision detection - Helper auto-kills viruses on touch
            if (game.hasHelper) {
                const helperVirus = game.viruses.find(v => v.virusType === virusTypes.HELPER && !v.dying && !v.destroyed);
                if (helperVirus) {
                    game.viruses.forEach(targetVirus => {
                        // Skip self, dying, destroyed, and other helpers
                        if (targetVirus === helperVirus || targetVirus.dying || targetVirus.destroyed || targetVirus.virusType === virusTypes.HELPER) {
                            return;
                        }

                        // Check collision using distance
                        const dx = helperVirus.x - targetVirus.x;
                        const dy = helperVirus.y - targetVirus.y;
                        const distSquared = dx * dx + dy * dy;
                        const radiusSum = helperVirus.radius + targetVirus.radius;

                        if (distSquared <= radiusSum * radiusSum) {
                            // Helper touched a virus - kill it!
                            const damageResult = targetVirus.takeDamage();

                            if (damageResult.killed) {
                                game.sanitizedViruses++;

                                // Handle Boss kill
                                if (damageResult.isBoss) {
                                    game.bossKilled = true;
                                    shake(4);
                                    playSound(200, 0.8, 'sawtooth', 0.3);
                                    createParticles(targetVirus.x, targetVirus.y, 80, '#000000', true);
                                    createFloatingText(targetVirus.x, targetVirus.y, 'BOSS DEFEATED!', '#ff0000');
                                }

                                // Create small zone for visual effect (NOT player created)
                                game.sanitizationZones.push(new SanitizationZone(targetVirus.x, targetVirus.y, false, false));

                                // Particles and sound
                                playSound(120, 0.1, 'sine', 0.1);
                                createParticles(targetVirus.x, targetVirus.y, 15, targetVirus.colorScheme.primary);

                                updateUI();

                                // Check for early win after Helper kills virus
                                checkEarlyWin();
                            }
                        }
                    });
                }
            }

            // Remove destroyed viruses
            game.viruses = game.viruses.filter(v => !v.destroyed);

            // Update and draw particles (batch for performance)
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }

            // Update and draw floating texts (batch for performance)
            for (let i = game.floatingTexts.length - 1; i >= 0; i--) {
                const t = game.floatingTexts[i];
                t.update();
                t.draw();
                if (t.life <= 0) {
                    game.floatingTexts.splice(i, 1);
                }
            }

            // Update combo decay
            if (game.combo > 0 && Date.now() - game.lastKillTime > game.comboDecayTime) {
                game.combo = 0;
                game.comboMultiplier = 1;
                updateUI();
            }

            // Draw targeting reticle
            drawReticle();

            // Check for early win
            checkEarlyWin();

            // Check level completion
            checkLevelComplete();

            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseleave', handleMouseLeave);

        // Touch events (mobile support)
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Tap to shoot on mobile (with debounce to prevent double-firing)
        let lastTouchEnd = 0;
        canvas.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd < 300) {
                // Prevent rapid double-taps
                e.preventDefault();
                return;
            }
            lastTouchEnd = now;

            if (e.changedTouches && e.changedTouches.length > 0) {
                handleClick(e);
            }
        }, { passive: false });

        // Initialize and start game
        initLeaderboard(); // Initialize leaderboard with defaults
        initAchievements(); // Initialize achievement system
        loadGame(); // Load saved progress
        updateUI(); // Update UI with loaded data
        initLevel();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
